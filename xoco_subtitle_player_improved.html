<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Xoco Subtitle Player Pro (Karaoke Edition) - Mejorado</title>
  <style>
    :root {
      --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --success-color: #10b981;
      --error-color: #ef4444;
      --warning-color: #f59e0b;
      --dark-bg: #0f172a;
      --surface-bg: #1e293b;
      --glass-bg: rgba(30, 41, 59, 0.8);
      --text-primary: #f8fafc;
      --text-secondary: #cbd5e1;
      --border-subtle: rgba(255, 255, 255, 0.1);
      --shadow-intense: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
      --transition-smooth: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      --blur-effect: blur(20px);
      --karaoke-color: #764ba2; /* Default karaoke color */
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--dark-bg);
      color: var(--text-primary);
      min-height: 100vh;
      overflow: hidden;
      user-select: none;
    }

    /* --- LAYOUT & PANELS --- */
    .app-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: var(--dark-bg);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .video-container, .main-ui-overlay {
      position: absolute;
      top:0; left:0;
      width: 100%;
      height: 100%;
      transition: width 0.4s ease, right 0.4s ease, left 0.4s ease;
    }

    .settings-panel, .playlist-panel {
      position: absolute;
      background: var(--glass-bg);
      backdrop-filter: var(--blur-effect);
      border: 1px solid var(--border-subtle);
      transition: var(--transition-smooth);
      z-index: 500;
    }

    .settings-panel {
      top: 2rem;
      left: 2rem;
      border-radius: 20px;
      padding: 1.5rem;
      max-width: 320px;
      box-shadow: var(--shadow-intense);
      transform: translateX(-150%);
    }

    .playlist-panel {
      top: 0;
      right: 0;
      width: 350px;
      height: 100%;
      border-left: 1px solid var(--border-subtle);
      transform: translateX(100%);
      display: flex;
      flex-direction: column;
    }

    /* --- VISIBILITY STATES --- */
    .app-container.settings-visible .settings-panel {
      transform: translateX(0);
    }
    
    .app-container.playlist-visible .playlist-panel {
      transform: translateX(0);
    }

    /* Adjust main content when panels are visible */
    .app-container.playlist-visible .video-container,
    .app-container.playlist-visible .main-ui-overlay {
        width: calc(100% - 350px);
    }

    /* --- FULLSCREEN BEHAVIOR --- */
    .app-container:fullscreen .settings-panel,
    .app-container:fullscreen .playlist-panel {
        transform: translateX(-150%) !important; /* Force hide */
    }
    .app-container:fullscreen .playlist-panel {
        transform: translateX(100%) !important; /* Force hide */
    }
    .app-container:fullscreen .video-container,
    .app-container:fullscreen .main-ui-overlay {
        width: 100% !important;
        left: 0 !important;
        right: 0 !important;
    }


    /* --- CONTROLS & UI --- */
    .loading-screen {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
      background: var(--dark-bg); display: flex; flex-direction: column;
      align-items: center; justify-content: center; z-index: 10000;
      opacity: 1; transition: var(--transition-smooth);
    }
    .loading-screen.hidden { opacity: 0; pointer-events: none; }
    .loading-spinner {
      width: 80px; height: 80px; border: 4px solid var(--border-subtle);
      border-top: 4px solid transparent; border-radius: 50%;
      background: var(--primary-gradient); animation: spin 1.2s linear infinite;
      margin-bottom: 2rem; box-shadow: var(--shadow-intense);
    }
    @keyframes spin { 100% { transform: rotate(360deg); } }
    .loading-text {
      font-size: 1.5rem; font-weight: 700; background: var(--primary-gradient);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text; margin-bottom: 0.5rem;
    }
    .loading-subtitle { color: var(--text-secondary); font-size: 1rem; }

    #video-background {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      object-fit: cover; z-index: 0; filter: brightness(0.5); display: none;
    }

    .drop-zone {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(102, 126, 234, 0.15); border: 4px dashed rgba(102, 126, 234, 0.8);
      display: none; align-items: center; justify-content: center;
      z-index: 9000; backdrop-filter: var(--blur-effect); animation: pulse 2s ease-in-out infinite;
    }
    .drop-zone.active { display: flex; }
    @keyframes pulse { 50% { opacity: 1; } }
    .drop-content {
      text-align: center; padding: 3rem; background: var(--glass-bg);
      border-radius: 24px; backdrop-filter: var(--blur-effect); box-shadow: var(--shadow-intense);
    }
    .drop-icon { font-size: 4rem; margin-bottom: 1rem; }
    .drop-text { font-size: 2rem; font-weight: 700; color: #667eea; margin-bottom: 0.5rem; }
    .drop-subtext { color: var(--text-secondary); }

    .upload-panel {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: var(--glass-bg); border: 1px solid var(--border-subtle);
      border-radius: 32px; padding: 3rem 2.5rem; text-align: center;
      backdrop-filter: var(--blur-effect); box-shadow: var(--shadow-intense);
      transition: var(--transition-smooth); z-index: 1000; max-width: 650px; width: 90%;
    }
    .upload-panel.hidden { opacity: 0; transform: translate(-50%, -50%) scale(0.8); pointer-events: none; }
    .app-title {
      font-size: 2.8rem; font-weight: 900; background: var(--primary-gradient);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text; margin-bottom: 1rem; text-align: center;
    }
    .app-subtitle { color: var(--text-secondary); font-size: 1.1rem; margin-bottom: 2.5rem; line-height: 1.6; }
    .file-upload-area { display: grid; grid-template-columns: 1fr; gap: 1.5rem; margin-bottom: 2.5rem; }
    @media (min-width: 600px) { .file-upload-area { grid-template-columns: 1fr 1fr; } .folder-upload-group { grid-column: 1 / -1; } }
    .file-input-group { position: relative; overflow: hidden; border-radius: 20px; transition: var(--transition-smooth); }
    .file-input { position: absolute; opacity: 0; width: 100%; height: 100%; cursor: pointer; }
    .file-input-label {
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      gap: 0.8rem; padding: 1.8rem 1.5rem; background: var(--primary-gradient); color: white;
      border-radius: 20px; cursor: pointer; font-weight: 700; font-size: 1.1rem;
      transition: var(--transition-smooth); box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
    }
    .file-input-label:hover { transform: scale(1.02); box-shadow: 0 15px 40px rgba(102, 126, 234, 0.5); }
    .file-icon { font-size: 2.2rem; }

    .status-dashboard { background: rgba(0, 0, 0, 0.4); border-radius: 20px; padding: 1.5rem; border: 1px solid var(--border-subtle); }
    .status-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1.5rem; }
    .status-card {
      display: flex; align-items: center; gap: 1rem; padding: 1rem;
      background: rgba(255, 255, 255, 0.05); border-radius: 12px;
      border: 1px solid var(--border-subtle); transition: var(--transition-smooth);
    }
    .status-indicator {
      width: 35px; height: 35px; border-radius: 50%; display: flex; align-items: center;
      justify-content: center; font-size: 1.1rem; font-weight: bold; transition: var(--transition-smooth); flex-shrink: 0;
    }
    .status-indicator.pending { background: var(--warning-color); }
    .status-indicator.success { background: var(--success-color); }
    .status-indicator.error { background: var(--error-color); }
    .status-info { text-align: left; overflow: hidden; }
    .status-title { font-weight: 600; margin-bottom: 0.25rem; }
    .status-description { font-size: 0.85rem; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    
    .video-player { width: 100%; height: 100%; object-fit: contain; }
    .video-placeholder {
      display: none; flex-direction: column; align-items: center; justify-content: center;
      text-align: center; color: var(--text-secondary); z-index: 5; position: absolute;
      top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; max-width: 500px;
    }
    .placeholder-icon { font-size: 5rem; margin-bottom: 1rem; opacity: 0.6; }

    .main-ui-overlay { z-index: 100; pointer-events: none; }
    .main-ui-overlay > * { pointer-events: auto; }
    .subtitle-overlay { position: absolute; bottom: 12%; left: 5%; right: 5%; text-align: center; transition: var(--transition-smooth); }
    .subtitle-text {
      display: inline-block; background: rgba(0, 0, 0, 0.85); color: white; padding: 1rem 2rem;
      border-radius: 16px; font-size: clamp(1.2rem, 3vw, 2.2rem); line-height: 1.5; font-weight: 600;
      text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8); border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: 0 15px 50px rgba(0, 0, 0, 0.8); opacity: 0; transform: translateY(20px);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    .subtitle-text.active { opacity: 1; transform: translateY(0); }
    .subtitle-word { transition: color 0.2s ease, transform 0.2s ease; display: inline-block; }
    .subtitle-word.highlight {
      transform: scale(1.05);
      color: var(--karaoke-color);
    }

    .controls-overlay {
      position: absolute; bottom: 3rem; left: 50%; transform: translateX(-50%);
      display: flex; gap: 1rem; align-items: center; opacity: 0;
      transition: var(--transition-smooth);
    }
    .app-container:hover .controls-overlay, .controls-overlay:focus-within { opacity: 1; }

    .control-button {
      width: 50px; height: 50px; border: none; border-radius: 50%;
      background: var(--glass-bg); color: white; font-size: 1.2rem; cursor: pointer;
      transition: var(--transition-smooth); backdrop-filter: var(--blur-effect);
      border: 1px solid var(--border-subtle); display: flex; align-items: center;
      justify-content: center; box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }
    .control-button svg { width: 24px; height: 24px; fill: currentColor; transition: transform 0.2s ease; }
    .control-button:hover:not(:disabled) { background: var(--primary-gradient); transform: scale(1.1); }
    .control-button:hover:not(:disabled) svg { transform: scale(1.1); }
    .control-button.active { background: var(--primary-gradient); }
    .control-button:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }

    .progress-container {
      position: absolute; bottom: 0; left: 0; width: 100%; height: 6px;
      background: rgba(255, 255, 255, 0.1); cursor: pointer; --progress-height-hover: 12px;
      transition: height 0.2s ease;
    }
    .progress-container:hover { height: var(--progress-height-hover); }
    .progress-bar { height: 100%; background: var(--primary-gradient); width: 0%; transition: width 0.1s linear; position: relative; border-radius: 0 3px 3px 0; }
    .progress-tooltip {
      position: absolute; bottom: calc(var(--progress-height-hover) + 8px); left: 0;
      transform: translateX(-50%); background: var(--glass-bg); border: 1px solid var(--border-subtle);
      color: white; padding: 5px 10px; border-radius: 8px; font-size: 0.9rem; font-weight: 600;
      opacity: 0; visibility: hidden; transition: opacity 0.2s ease; white-space: nowrap; pointer-events: none; z-index: 10;
    }
    .progress-container:hover .progress-tooltip { opacity: 1; visibility: visible; }

    .voice-indicator {
      position: absolute; top: 2rem; right: 2rem; display: flex; gap: 5px;
      align-items: flex-end; opacity: 0; transition: var(--transition-smooth);
    }
    .voice-indicator.active { opacity: 1; }
    .voice-bar { width: 4px; background: var(--primary-gradient); border-radius: 2px; animation: voice-wave 0.8s ease-in-out infinite alternate; }
    .voice-bar:nth-child(1) { height: 20px; animation-delay: 0s; }
    .voice-bar:nth-child(2) { height: 30px; animation-delay: 0.1s; }
    .voice-bar:nth-child(3) { height: 25px; animation-delay: 0.2s; }
    .voice-bar:nth-child(4) { height: 35px; animation-delay: 0.3s; }
    .voice-bar:nth-child(5) { height: 15px; animation-delay: 0.4s; }
    @keyframes voice-wave { 100% { transform: scaleY(1); opacity: 1; } 0% { transform: scaleY(0.2); opacity: 0.5; } }

    .settings-title { font-size: 1.2rem; font-weight: 700; margin-bottom: 1.5rem; color: var(--text-primary); }
    .setting-item { margin-bottom: 1.2rem; }
    .setting-item:last-child { margin-bottom: 0; }
    .setting-item.hidden-setting { display: none; }
    .setting-label { display: block; font-size: 0.9rem; font-weight: 600; color: var(--text-secondary); margin-bottom: 0.75rem; }
    .setting-input { width: 100%; padding: 0.7rem 1rem; background: rgba(0, 0, 0, 0.4); border: 1px solid var(--border-subtle); border-radius: 10px; color: var(--text-primary); font-size: 0.9rem; transition: var(--transition-smooth); }
    input[type="color"].setting-input { padding: 0.3rem; height: 40px; }
    .setting-range { -webkit-appearance: none; appearance: none; height: 6px; background: rgba(255, 255, 255, 0.2); border-radius: 3px; outline: none; padding: 0; }
    .setting-range::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: var(--primary-gradient); border-radius: 50%; cursor: pointer; }
    .setting-range::-moz-range-thumb { width: 18px; height: 18px; background: var(--primary-gradient); border-radius: 50%; cursor: pointer; border: none; }
    .toggle-switch-container { display: flex; justify-content: space-between; align-items: center; }
    .toggle-switch-container .setting-label { margin-bottom: 0; }
    .setting-toggle { position: absolute; opacity: 0; width: 0; height: 0; }
    .toggle-switch { position: relative; display: inline-block; width: 50px; height: 28px; flex-shrink: 0; cursor: pointer; }
    .toggle-switch-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.4); transition: .4s; border-radius: 28px; }
    .toggle-switch-slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
    .setting-toggle:checked + .toggle-switch-slider { background: var(--primary-gradient); }
    .setting-toggle:disabled + .toggle-switch-slider { opacity: 0.5; cursor: not-allowed; }
    .setting-toggle:checked + .toggle-switch-slider:before { transform: translateX(22px); }

    .notification {
      position: fixed; top: 2rem; right: 2rem; background: var(--glass-bg); border: 1px solid var(--border-subtle);
      border-radius: 16px; padding: 1rem 1.5rem; backdrop-filter: var(--blur-effect); box-shadow: var(--shadow-intense);
      z-index: 10000; transform: translateX(calc(100% + 2rem)); transition: var(--transition-smooth); min-width: 320px;
    }
    .notification.show { transform: translateX(0); }
    .notification.success { border-left: 4px solid var(--success-color); }
    .notification.error { border-left: 4px solid var(--error-color); }
    .notification.warning { border-left: 4px solid var(--warning-color); }
    .notification-content { display: flex; align-items: center; gap: 1rem; }
    .notification-icon { font-size: 1.8rem; }
    .notification-title { font-weight: 700; margin-bottom: 0.25rem; color: var(--text-primary); }
    .notification-message { font-size: 0.95rem; color: var(--text-secondary); }

    .playlist-title { font-size: 1.2rem; font-weight: 700; padding: 1.5rem; color: var(--text-primary); flex-shrink: 0; border-bottom: 1px solid var(--border-subtle); }
    .playlist-list { list-style: none; overflow-y: auto; flex-grow: 1; }
    .playlist-item { padding: 1rem 1.5rem; cursor: pointer; border-bottom: 1px solid var(--border-subtle); transition: background 0.2s ease; font-size: 0.9rem; }
    .playlist-item:hover { background: rgba(255, 255, 255, 0.05); }
    .playlist-item.active { background: var(--primary-gradient); color: white; }
    .playlist-item-name { font-weight: 600; margin-bottom: 0.25rem; }
    .playlist-item-info { color: var(--text-secondary); font-size: 0.8rem; }
    .playlist-item.active .playlist-item-info { color: rgba(255, 255, 255, 0.8); }
  </style>
</head>
<body>
  <div class="loading-screen" id="loadingScreen">
    <div class="loading-spinner"></div>
    <div class="loading-text">Xoco Subtitle Player Pro</div>
    <div class="loading-subtitle">Inicializando sistema mejorado...</div>
  </div>

  <div class="drop-zone" id="dropZone">
    <div class="drop-content">
      <div class="drop-icon">📁</div>
      <div class="drop-text">Suelta tu carpeta aquí</div>
      <div class="drop-subtext">Archivos de video y subtítulos</div>
    </div>
  </div>

  <div class="app-container" id="appContainer">
    <div class="upload-panel" id="uploadPanel">
      <h1 class="app-title">Xoco Subtitle Player Pro</h1>
      <p class="app-subtitle">Versión mejorada con sincronización avanzada de voz y texto. Sube tus archivos de video y subtítulos para comenzar.</p>
      
      <div class="file-upload-area">
        <div class="file-input-group">
          <input type="file" id="videoInput" class="file-input" accept="video/*" aria-label="Seleccionar archivo de video">
          <label for="videoInput" class="file-input-label">
            <span class="file-icon">🎬</span>
            <span>Video</span>
          </label>
        </div>
        
        <div class="file-input-group">
          <input type="file" id="subtitleInput" class="file-input" accept=".srt,.vtt" aria-label="Seleccionar archivo de subtítulos">
          <label for="subtitleInput" class="file-input-label">
            <span class="file-icon">📝</span>
            <span>Subtítulos</span>
          </label>
        </div>
        
        <div class="file-input-group folder-upload-group">
          <input type="file" id="folderInput" class="file-input" webkitdirectory multiple aria-label="Seleccionar carpeta con videos y subtítulos">
          <label for="folderInput" class="file-input-label">
            <span class="file-icon">📁</span>
            <span>Carpeta Completa</span>
          </label>
        </div>
      </div>
      
      <div class="status-dashboard">
        <div class="status-grid">
          <div class="status-card">
            <div class="status-indicator pending" id="videoStatusIndicator">⏳</div>
            <div class="status-info">
              <div class="status-title">Video</div>
              <div class="status-description" id="videoStatusText">Esperando archivo...</div>
            </div>
          </div>
          
          <div class="status-card">
            <div class="status-indicator pending" id="subtitleStatusIndicator">⏳</div>
            <div class="status-info">
              <div class="status-title">Subtítulos</div>
              <div class="status-description" id="subtitleStatusText">Esperando archivo...</div>
            </div>
          </div>
          
          <div class="status-card">
            <div class="status-indicator success" id="systemStatusIndicator">✅</div>
            <div class="status-info">
              <div class="status-title">Sistema</div>
              <div class="status-description" id="systemStatusText">Sistema listo</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="video-container">
      <video id="videoPlayer" class="video-player" preload="metadata" aria-label="Reproductor de video"></video>
      <video id="video-background" muted loop></video>
      <div class="video-placeholder" id="videoPlaceholder">
        <div class="placeholder-icon">🎬</div>
        <p>Carga un video para comenzar</p>
      </div>
    </div>

    <div class="main-ui-overlay">
        <div class="subtitle-overlay" id="subtitleOverlay">
            <div class="subtitle-text" id="subtitleText" role="region" aria-live="polite" aria-label="Subtítulos"></div>
        </div>

        <div class="voice-indicator" id="voiceIndicator" aria-label="Indicador de voz activa">
            <div class="voice-bar"></div>
            <div class="voice-bar"></div>
            <div class="voice-bar"></div>
            <div class="voice-bar"></div>
            <div class="voice-bar"></div>
        </div>

        <div class="controls-overlay">
            <button class="control-button" id="prevBtn" disabled aria-label="Anterior"></button>
            <button class="control-button" id="playPauseBtn" disabled aria-label="Reproducir"></button>
            <button class="control-button" id="nextBtn" disabled aria-label="Siguiente"></button>
            <button class="control-button" id="stopBtn" disabled aria-label="Detener"></button>
            <button class="control-button" id="fullscreenBtn" disabled aria-label="Pantalla completa"></button>
            <button class="control-button" id="settingsToggleBtn" disabled aria-label="Configuración"></button>
            <button class="control-button" id="playlistToggleBtn" disabled aria-label="Lista de reproducción"></button>
        </div>

        <div class="settings-panel" id="settingsPanel">
            <h3 class="settings-title">Configuración Avanzada</h3>
            
            <div class="setting-item">
                <label class="setting-label" for="voiceSelect">Voz del Sistema</label>
                <select id="voiceSelect" class="setting-input">
                    <option value="">Cargando voces...</option>
                </select>
            </div>
            
            <div class="setting-item">
                <label class="setting-label" for="voiceRate">Velocidad de Voz: <span id="voiceRateValue">1.5x</span></label>
                <input type="range" id="voiceRate" class="setting-input setting-range" min="0.5" max="3" step="0.1" value="1.5">
            </div>
            
            <div class="setting-item">
                <label class="setting-label" for="voicePitch">Tono de Voz: <span id="voicePitchValue">1.0</span></label>
                <input type="range" id="voicePitch" class="setting-input setting-range" min="0.5" max="2" step="0.1" value="1">
            </div>
            
            <div class="setting-item">
                <label class="setting-label" for="fontSize">Tamaño de Subtítulos: <span id="fontSizeValue">100%</span></label>
                <input type="range" id="fontSize" class="setting-input setting-range" min="50" max="200" step="10" value="100">
            </div>
            
            <div class="setting-item">
                <label class="setting-label" for="syncOffset">Ajuste de Sincronización: <span id="syncOffsetValue">0 ms</span></label>
                <input type="range" id="syncOffset" class="setting-input setting-range" min="-2000" max="2000" step="50" value="0" title="Doble clic para resetear">
            </div>

            <div class="setting-item">
                <label class="setting-label" for="voiceLatencyCompensation">Compensación de Latencia: <span id="voiceLatencyCompensationValue">100 ms</span></label>
                <input type="range" id="voiceLatencyCompensation" class="setting-input setting-range" min="0" max="500" step="25" value="100" title="Ajuste automático de latencia de voz">
            </div>
            
            <div class="setting-item">
                <div class="toggle-switch-container">
                    <label class="setting-label" for="showSubtitlesToggle">Mostrar Subtítulos</label>
                    <div class="toggle-switch">
                        <input type="checkbox" id="showSubtitlesToggle" class="setting-toggle" checked>
                        <span class="toggle-switch-slider"></span>
                    </div>
                </div>
            </div>
            
            <div class="setting-item">
                <div class="toggle-switch-container">
                    <label class="setting-label" for="karaokeToggle">Resaltado Karaoke</label>
                    <div class="toggle-switch">
                        <input type="checkbox" id="karaokeToggle" class="setting-toggle">
                        <span class="toggle-switch-slider"></span>
                    </div>
                </div>
            </div>
            
            <div class="setting-item hidden-setting" id="karaokeColorContainer">
                <label class="setting-label" for="karaokeColor">Color de Resaltado</label>
                <input type="color" id="karaokeColor" class="setting-input">
            </div>
            
            <div class="setting-item">
                <div class="toggle-switch-container">
                    <label class="setting-label" for="muteVideoToggle">Silenciar Audio del Video</label>
                    <div class="toggle-switch">
                        <input type="checkbox" id="muteVideoToggle" class="setting-toggle" checked>
                        <span class="toggle-switch-slider"></span>
                    </div>
                </div>
            </div>
        </div>

        <div class="progress-container" id="progressContainer">
            <div class="progress-bar" id="progressBar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
            <div class="progress-tooltip" id="progressTooltip">00:00</div>
        </div>
    </div>
    
    <div class="playlist-panel" id="playlistPanel">
        <h3 class="playlist-title">Lista de Reproducción</h3>
        <ul class="playlist-list" id="playlistList"></ul>
    </div>
  </div>

  <script>
    const CONSTANTS = {
      ICONS: {
        PLAY: `<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"></path></svg>`,
        PAUSE: `<svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>`,
        STOP: `<svg viewBox="0 0 24 24"><path d="M6 6h12v12H6z"></path></svg>`,
        FULLSCREEN: `<svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"></path></svg>`,
        NEXT: `<svg viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"></path></svg>`,
        PREV: `<svg viewBox="0 0 24 24"><path d="M18 6l-8.5 6 8.5 6V6zM6 6v12H4V6h2z"></path></svg>`,
        SETTINGS: `<svg viewBox="0 0 24 24"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"></path></svg>`,
        PLAYLIST: `<svg viewBox="0 0 24 24"><path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"></path></svg>`,
        STATUS_PENDING: '⏳', STATUS_SUCCESS: '✅', STATUS_ERROR: '❌'
      },
      TEXT: {
        VOICES_LOADING: 'Cargando voces...',
        VIDEO_WAITING: 'Esperando archivo...',
        SUBTITLE_WAITING: 'Esperando archivo...',
        SYSTEM_INIT: 'Inicializando...',
        SYSTEM_READY: 'Sistema listo'
      },
      STATUS: { PENDING: 'pending', SUCCESS: 'success', ERROR: 'error' }
    };

    class ImprovedSubtitlePlayer {
      constructor() {
        this.dom = {
          appContainer: document.getElementById('appContainer'),
          loadingScreen: document.getElementById('loadingScreen'),
          uploadPanel: document.getElementById('uploadPanel'),
          videoInput: document.getElementById('videoInput'),
          subtitleInput: document.getElementById('subtitleInput'),
          folderInput: document.getElementById('folderInput'),
          videoPlayer: document.getElementById('videoPlayer'),
          videoBackground: document.getElementById('video-background'),
          subtitleOverlay: document.getElementById('subtitleOverlay'),
          subtitleText: document.getElementById('subtitleText'),
          playPauseBtn: document.getElementById('playPauseBtn'),
          stopBtn: document.getElementById('stopBtn'),
          fullscreenBtn: document.getElementById('fullscreenBtn'),
          nextBtn: document.getElementById('nextBtn'),
          prevBtn: document.getElementById('prevBtn'),
          settingsToggleBtn: document.getElementById('settingsToggleBtn'),
          playlistToggleBtn: document.getElementById('playlistToggleBtn'),
          progressBar: document.getElementById('progressBar'),
          progressContainer: document.getElementById('progressContainer'),
          progressTooltip: document.getElementById('progressTooltip'),
          voiceIndicator: document.getElementById('voiceIndicator'),
          settingsPanel: document.getElementById('settingsPanel'),
          playlistPanel: document.getElementById('playlistPanel'),
          playlistList: document.getElementById('playlistList'),
          voiceSelect: document.getElementById('voiceSelect'),
          voiceRate: document.getElementById('voiceRate'),
          voiceRateValue: document.getElementById('voiceRateValue'),
          voicePitch: document.getElementById('voicePitch'),
          voicePitchValue: document.getElementById('voicePitchValue'),
          fontSize: document.getElementById('fontSize'),
          fontSizeValue: document.getElementById('fontSizeValue'),
          syncOffset: document.getElementById('syncOffset'),
          syncOffsetValue: document.getElementById('syncOffsetValue'),
          voiceLatencyCompensation: document.getElementById('voiceLatencyCompensation'),
          voiceLatencyCompensationValue: document.getElementById('voiceLatencyCompensationValue'),
          videoStatusIndicator: document.getElementById('videoStatusIndicator'),
          videoStatusText: document.getElementById('videoStatusText'),
          subtitleStatusIndicator: document.getElementById('subtitleStatusIndicator'),
          subtitleStatusText: document.getElementById('subtitleStatusText'),
          systemStatusIndicator: document.getElementById('systemStatusIndicator'),
          systemStatusText: document.getElementById('systemStatusText'),
          dropZone: document.getElementById('dropZone'),
          videoPlaceholder: document.getElementById('videoPlaceholder'),
          showSubtitlesToggle: document.getElementById('showSubtitlesToggle'),
          karaokeToggle: document.getElementById('karaokeToggle'),
          karaokeColor: document.getElementById('karaokeColor'),
          karaokeColorContainer: document.getElementById('karaokeColorContainer'),
          muteVideoToggle: document.getElementById('muteVideoToggle'),
        };

        this.state = {
          isReady: false, isPlaying: false, hasVideo: false, hasSubtitles: false,
          subtitles: [], currentSubtitleIndex: -1, duration: 0, voices: [],
          settings: {},
          playlist: [], currentPlaylistIndex: -1, tempVideoFile: null, tempSubtitleFile: null,
          isSettingsVisible: false, isPlaylistVisible: false,
          wasPlaylistVisibleOnFullscreen: false, wasSettingsVisibleOnFullscreen: false,
          // Nuevas propiedades para mejorar la sincronización
          speechStartTime: 0,
          speechDuration: 0,
          currentUtterance: null,
          wordTimings: [],
          subtitleStartTime: 0
        };

        this.speechSynthesis = window.speechSynthesis;
        this.animationFrame = null;
        this.startTime = 0; this.pausedTime = 0;
        
        this.settingsConfig = {
            voiceRate: { el: this.dom.voiceRate, label: this.dom.voiceRateValue, suffix: 'x', type: 'float' },
            voicePitch: { el: this.dom.voicePitch, label: this.dom.voicePitchValue, type: 'float' },
            fontSize: { el: this.dom.fontSize, label: this.dom.fontSizeValue, suffix: '%', type: 'int' },
            syncOffset: { el: this.dom.syncOffset, label: this.dom.syncOffsetValue, suffix: ' ms', type: 'int' },
            voiceLatencyCompensation: { el: this.dom.voiceLatencyCompensation, label: this.dom.voiceLatencyCompensationValue, suffix: ' ms', type: 'int' },
            showSubtitles: { el: this.dom.showSubtitlesToggle, type: 'bool' },
            karaokeHighlight: { el: this.dom.karaokeToggle, type: 'bool' },
            karaokeColor: { el: this.dom.karaokeColor, type: 'string' },
            muteVideo: { el: this.dom.muteVideoToggle, type: 'bool' },
            selectedVoiceURI: { el: this.dom.voiceSelect, type: 'string' }
        };
        
        this.init();
      }

      async init() {
        this.setButtonIcons();
        this.resetStatus();
        
        this.state.settings = this.loadSettings();
        this.applySettings();
        this.bindEvents();
        
        try {
            await this.initSpeechSynthesis();
            this.updateSystemStatus(CONSTANTS.STATUS.SUCCESS, CONSTANTS.TEXT.SYSTEM_READY);
            setTimeout(() => this.dom.loadingScreen.classList.add('hidden'), 500);
        } catch (error) {
            this.showNotification('Error al iniciar la síntesis de voz.', 'error');
            this.updateSystemStatus(CONSTANTS.STATUS.ERROR, 'Error de voz');
        }
      }
      
      setButtonIcons() {
        this.dom.playPauseBtn.innerHTML = CONSTANTS.ICONS.PLAY;
        this.dom.playPauseBtn.setAttribute('aria-label', 'Reproducir (Espacio)');
        this.dom.stopBtn.innerHTML = CONSTANTS.ICONS.STOP;
        this.dom.stopBtn.setAttribute('aria-label', 'Detener (Escape)');
        this.dom.fullscreenBtn.innerHTML = CONSTANTS.ICONS.FULLSCREEN;
        this.dom.fullscreenBtn.setAttribute('aria-label', 'Pantalla completa (F)');
        this.dom.nextBtn.innerHTML = CONSTANTS.ICONS.NEXT;
        this.dom.nextBtn.setAttribute('aria-label', 'Siguiente (Shift + Flecha Derecha)');
        this.dom.prevBtn.innerHTML = CONSTANTS.ICONS.PREV;
        this.dom.prevBtn.setAttribute('aria-label', 'Anterior (Shift + Flecha Izquierda)');
        this.dom.settingsToggleBtn.innerHTML = CONSTANTS.ICONS.SETTINGS;
        this.dom.playlistToggleBtn.innerHTML = CONSTANTS.ICONS.PLAYLIST;
      }

      async initSpeechSynthesis() {
        if (!this.speechSynthesis) throw new Error('Síntesis de voz no soportada');
        return new Promise((resolve) => {
            const loadVoices = () => {
                const voices = this.speechSynthesis.getVoices();
                if (voices.length > 0) {
                    this.state.voices = voices;
                    this.populateVoiceList(); resolve();
                }
            };
            this.speechSynthesis.onvoiceschanged = loadVoices;
            loadVoices(); 
            setTimeout(() => {
                if (this.state.voices.length === 0) loadVoices();
                if (this.state.voices.length > 0) resolve();
                else { 
                    this.showNotification("No se pudieron cargar las voces del sistema.", "warning");
                    resolve();
                }
            }, 1000);
        });
      }

      bindEvents() {
        this.dom.videoInput.addEventListener('change', e => this.handleFile(e.target.files[0], 'video'));
        this.dom.subtitleInput.addEventListener('change', e => this.handleFile(e.target.files[0], 'subtitle'));
        this.dom.folderInput.addEventListener('change', e => this.handleFolderSelect(e.target.files));
        
        this.dom.playPauseBtn.addEventListener('click', () => this.togglePlayPause());
        this.dom.stopBtn.addEventListener('click', () => this.stop());
        this.dom.nextBtn.addEventListener('click', () => this.playNext());
        this.dom.prevBtn.addEventListener('click', () => this.playPrev());
        this.dom.fullscreenBtn.addEventListener('click', () => this.toggleFullscreen());
        
        this.dom.settingsToggleBtn.addEventListener('click', () => {
          this.state.isSettingsVisible = !this.state.isSettingsVisible;
          this.updateUIVisibility();
        });
        this.dom.playlistToggleBtn.addEventListener('click', () => {
          this.state.isPlaylistVisible = !this.state.isPlaylistVisible;
          this.updateUIVisibility();
        });

        this.dom.videoPlayer.addEventListener('loadeddata', () => this.onVideoLoaded());
        this.dom.videoPlayer.addEventListener('ended', () => this.playNext(true));
        
        this.dom.progressContainer.addEventListener('click', e => this.seek(e));
        this.dom.progressContainer.addEventListener('mousemove', e => this.updateProgressTooltip(e));

        Object.keys(this.settingsConfig).forEach(key => {
            const config = this.settingsConfig[key];
            const eventType = (config.type === 'bool' || config.el.type === 'color') ? 'change' : 'input';
            config.el.addEventListener(eventType, e => {
                let value;
                if(config.type === 'bool') value = e.target.checked;
                else if(config.type === 'float') value = parseFloat(e.target.value);
                else if(config.type === 'int') value = parseInt(e.target.value);
                else value = e.target.value;
                this.updateSetting(key, value);
            });
        });
        
        this.dom.syncOffset.addEventListener('dblclick', () => this.updateSetting('syncOffset', 0));
        this.dom.voiceLatencyCompensation.addEventListener('dblclick', () => this.updateSetting('voiceLatencyCompensation', 100));

        // Event listeners específicos para toggle switches
        const toggleSwitches = [
            { element: this.dom.showSubtitlesToggle, setting: 'showSubtitles' },
            { element: this.dom.karaokeToggle, setting: 'karaokeHighlight' },
            { element: this.dom.muteVideoToggle, setting: 'muteVideo' }
        ];
        
        toggleSwitches.forEach(({ element, setting }) => {
            // Event listener para el input checkbox
            element.addEventListener('change', (e) => {
                this.updateSetting(setting, e.target.checked);
            });
            
            // Event listener para el contenedor del toggle switch (para clics en el slider)
            const toggleContainer = element.parentElement;
            toggleContainer.addEventListener('click', (e) => {
                if (e.target !== element) {
                    e.preventDefault();
                    element.checked = !element.checked;
                    this.updateSetting(setting, element.checked);
                }
            });
        });

        const dropZone = this.dom.dropZone;
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(evt => document.body.addEventListener(evt, e => { e.preventDefault(); e.stopPropagation(); }));
        document.body.addEventListener('dragenter', () => dropZone.classList.add('active'));
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('active'));
        dropZone.addEventListener('drop', e => {
            dropZone.classList.remove('active');
            this.handleFolderSelect(e.dataTransfer.files);
        });
        
        this.dom.playlistList.addEventListener('click', e => {
            const item = e.target.closest('.playlist-item');
            if(item && item.dataset.index) {
                this.loadPlaylistItem(parseInt(item.dataset.index, 10));
            }
        });
        
        document.addEventListener('keydown', e => this.handleKeyPress(e));
        document.addEventListener('fullscreenchange', () => this.handleFullscreenChange());
      }
      
      updateUIVisibility() {
        this.dom.appContainer.classList.toggle('settings-visible', this.state.isSettingsVisible);
        this.dom.settingsToggleBtn.classList.toggle('active', this.state.isSettingsVisible);
        this.dom.appContainer.classList.toggle('playlist-visible', this.state.isPlaylistVisible);
        this.dom.playlistToggleBtn.classList.toggle('active', this.state.isPlaylistVisible);
      }
      
      handleFullscreenChange() {
        if (document.fullscreenElement) {
            this.state.wasPlaylistVisibleOnFullscreen = this.state.isPlaylistVisible;
            this.state.wasSettingsVisibleOnFullscreen = this.state.isSettingsVisible;
            this.state.isPlaylistVisible = false;
            this.state.isSettingsVisible = false;
        } else {
            this.state.isPlaylistVisible = this.state.wasPlaylistVisibleOnFullscreen;
            this.state.isSettingsVisible = this.state.wasSettingsVisibleOnFullscreen;
        }
        this.updateUIVisibility();
      }

      updateProgressTooltip(event) {
        const duration = this.state.duration;
        if (!duration || duration <= 0) return;
        const rect = this.dom.progressContainer.getBoundingClientRect();
        const percent = Math.max(0, Math.min(1, (event.clientX - rect.left) / rect.width));
        const hoverTime = duration * percent / 1000;
        
        const formatTime = (seconds) => {
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60);
            return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
        };
        this.dom.progressTooltip.textContent = formatTime(hoverTime);
        this.dom.progressTooltip.style.left = `${percent * 100}%`;
      }
      
      async handleFolderSelect(files) {
          this.showNotification("Procesando carpeta...", "success");
          const videoFiles = new Map();
          const subtitleFiles = new Map();
          const videoExtensions = ['mp4', 'webm', 'mov', 'ogg', 'mkv'];
          const subtitleExtensions = ['srt', 'vtt'];

          for (const file of files) {
              const nameParts = file.name.split('.');
              const extension = nameParts.pop().toLowerCase();
              const baseName = nameParts.join('.');
              
              if (videoExtensions.includes(extension)) {
                  videoFiles.set(baseName, file);
              } else if (subtitleExtensions.includes(extension)) {
                  subtitleFiles.set(baseName, file);
              }
          }

          const newPlaylist = [];
          for (const [baseName, videoFile] of videoFiles) {
              if (subtitleFiles.has(baseName)) {
                  newPlaylist.push({
                      name: baseName,
                      videoFile: videoFile,
                      subtitleFile: subtitleFiles.get(baseName)
                  });
              }
          }

          if (newPlaylist.length > 0) {
              this.state.playlist = newPlaylist;
              this.showNotification(`${newPlaylist.length} video(s) emparejados.`, "success");
              this.renderPlaylist();
              this.checkIfReady();
          } else {
              this.showNotification("No se encontraron pares de video/subtítulos.", "warning");
          }
      }
      
      async handleFile(file, type = null) {
        if (!file) return;
        let fileType = type;
        if (!fileType) {
            const videoExtensions = ['mp4', 'webm', 'mov', 'ogg', 'mkv'];
            const subtitleExtensions = ['srt', 'vtt'];
            const extension = file.name.split('.').pop().toLowerCase();
            if (videoExtensions.includes(extension)) fileType = 'video';
            else if (subtitleExtensions.includes(extension)) fileType = 'subtitle';
            else {
                this.showNotification('Tipo de archivo no soportado.', 'error');
                return;
            }
        }

        if (fileType === 'video') {
            this.state.tempVideoFile = file;
            this.updateVideoStatus(CONSTANTS.STATUS.SUCCESS, file.name);
        } else if (fileType === 'subtitle') {
            this.state.tempSubtitleFile = file;
            this.updateSubtitleStatus(CONSTANTS.STATUS.SUCCESS, file.name);
        }
        this.checkIfReady();
      }

      checkIfReady() {
          const hasFiles = (this.state.tempVideoFile && this.state.tempSubtitleFile) || this.state.playlist.length > 0;
          if (hasFiles && !this.state.isReady) {
              this.state.isReady = true;
              this.dom.uploadPanel.classList.add('hidden');
              [this.dom.playPauseBtn, this.dom.stopBtn, this.dom.nextBtn, this.dom.prevBtn, this.dom.fullscreenBtn, this.dom.settingsToggleBtn, this.dom.playlistToggleBtn].forEach(btn => btn.disabled = false);
              
              if (this.state.playlist.length > 0) {
                  this.loadPlaylistItem(0);
              } else {
                  this.loadMedia(this.state.tempVideoFile, this.state.tempSubtitleFile);
              }
          }
      }

      async loadMedia(videoFile, subtitleFile) {
          try {
              if (videoFile) {
                  const videoURL = URL.createObjectURL(videoFile);
                  this.dom.videoPlayer.src = videoURL;
                  this.dom.videoPlayer.muted = this.state.settings.muteVideo;
                  this.state.hasVideo = true;
                  this.dom.videoPlaceholder.style.display = 'none';
              }

              if (subtitleFile) {
                  const subtitleText = await subtitleFile.text();
                  this.state.subtitles = this.parseSubtitles(subtitleText);
                  this.state.hasSubtitles = true;
              }

              this.showNotification('Archivos cargados correctamente.', 'success');
          } catch (error) {
              this.showNotification('Error al cargar los archivos.', 'error');
              console.error('Error loading media:', error);
          }
      }

      parseSubtitles(text) {
          const subtitles = [];
          const lines = text.trim().split('\n');
          let currentSubtitle = null;
          let index = 0;

          for (let i = 0; i < lines.length; i++) {
              const line = lines[i].trim();
              
              if (/^\d+$/.test(line)) {
                  if (currentSubtitle) {
                      currentSubtitle.index = index++;
                      subtitles.push(currentSubtitle);
                  }
                  currentSubtitle = { id: parseInt(line) };
              } else if (line.includes('-->')) {
                  const [start, end] = line.split('-->').map(t => this.parseTime(t.trim()));
                  if (currentSubtitle) {
                      currentSubtitle.start = start;
                      currentSubtitle.end = end;
                  }
              } else if (line && currentSubtitle && !currentSubtitle.text) {
                  currentSubtitle.text = line;
              } else if (line && currentSubtitle && currentSubtitle.text) {
                  currentSubtitle.text += ' ' + line;
              }
          }

          if (currentSubtitle) {
              currentSubtitle.index = index++;
              subtitles.push(currentSubtitle);
          }

          return subtitles;
      }

      parseTime(timeStr) {
          const parts = timeStr.replace(',', '.').split(':');
          const seconds = parseFloat(parts[2]);
          const minutes = parseInt(parts[1]);
          const hours = parseInt(parts[0]);
          return (hours * 3600 + minutes * 60 + seconds) * 1000;
      }

      renderPlaylist() {
          this.dom.playlistList.innerHTML = '';
          this.state.playlist.forEach((item, index) => {
              const li = document.createElement('li');
              li.className = 'playlist-item';
              li.dataset.index = index;
              if (index === this.state.currentPlaylistIndex) li.classList.add('active');
              li.innerHTML = `
                  <div class="playlist-item-name">${item.name}</div>
                  <div class="playlist-item-info">Video + Subtítulos</div>
              `;
              this.dom.playlistList.appendChild(li);
          });
      }

      loadPlaylistItem(index) {
          if (index < 0 || index >= this.state.playlist.length) return;
          this.state.currentPlaylistIndex = index;
          const item = this.state.playlist[index];
          this.loadMedia(item.videoFile, item.subtitleFile);
          this.renderPlaylist();
      }

      onVideoLoaded() {
          this.state.duration = this.dom.videoPlayer.duration * 1000;
          this.showNotification('Video cargado correctamente.', 'success');
      }

      playNext(auto = false) {
          if (this.state.playlist.length > 0) {
              const nextIndex = (this.state.currentPlaylistIndex + 1) % this.state.playlist.length;
              this.loadPlaylistItem(nextIndex);
              if (auto && this.state.isPlaying) {
                  setTimeout(() => this.play(), 500);
              }
          }
      }

      playPrev() {
          if (this.state.playlist.length > 0) {
              const prevIndex = this.state.currentPlaylistIndex === 0 ? this.state.playlist.length - 1 : this.state.currentPlaylistIndex - 1;
              this.loadPlaylistItem(prevIndex);
          }
      }

      togglePlayPause() {
          if (this.state.isPlaying) this.pause();
          else this.play();
      }

      play() {
          if (!this.state.isReady) return;
          this.state.isPlaying = true;
          
          if (this.state.hasVideo) {
              this.dom.videoPlayer.play();
          } else {
              this.startTime = performance.now() - this.pausedTime;
          }
          
          this.dom.playPauseBtn.innerHTML = CONSTANTS.ICONS.PAUSE;
          this.dom.playPauseBtn.setAttribute('aria-label', 'Pausar (Espacio)');
          
          if (!this.animationFrame) this.animationFrame = requestAnimationFrame(this.onTimeUpdate.bind(this));
      }

      pause() {
          this.state.isPlaying = false;
          if (this.state.hasVideo) this.dom.videoPlayer.pause();
          else this.pausedTime = performance.now() - this.startTime;
          
          this.speechSynthesis.cancel();
          this.dom.playPauseBtn.innerHTML = CONSTANTS.ICONS.PLAY;
          this.dom.playPauseBtn.setAttribute('aria-label', 'Reproducir (Espacio)');
          this.dom.voiceIndicator.classList.remove('active');
          
          cancelAnimationFrame(this.animationFrame);
          this.animationFrame = null;
      }
      
      resetStatus() {
        this.updateVideoStatus(CONSTANTS.STATUS.PENDING, CONSTANTS.TEXT.VIDEO_WAITING);
        this.updateSubtitleStatus(CONSTANTS.STATUS.PENDING, CONSTANTS.TEXT.SUBTITLE_WAITING);
        this.updateSystemStatus(CONSTANTS.STATUS.SUCCESS, CONSTANTS.TEXT.SYSTEM_READY);
      }

      resetCurrentMediaState() {
          if (this.state.isPlaying) this.pause();
          if (this.state.hasVideo) this.dom.videoPlayer.currentTime = 0;
          this.pausedTime = 0; this.startTime = 0;
          this.state.currentSubtitleIndex = -1;
          this.state.hasVideo = false; this.state.hasSubtitles = false; this.state.subtitles = [];
          this.dom.progressBar.style.width = '0%';
          this.dom.progressBar.setAttribute('aria-valuenow', '0');
          this.dom.subtitleText.classList.remove('active');
          this.dom.subtitleText.innerHTML = '';
          this.dom.videoBackground.style.display = 'none';
          this.dom.videoPlaceholder.style.display = 'none';
      }

      stop() {
          this.pause();
          this.resetCurrentMediaState();
          
          // Si hay una playlist, mostrar opciones
          if (this.state.playlist.length > 0) {
              this.showStopMenu();
          } else {
              this.performFullStop();
          }
      }
      
      showStopMenu() {
          const menu = document.createElement('div');
          menu.className = 'stop-menu';
          menu.innerHTML = `
              <div class="stop-menu-content">
                  <h3 class="stop-menu-title">¿Qué deseas hacer?</h3>
                  <button class="stop-menu-button" id="backToPlaylist">Volver a la Lista de Videos</button>
                  <button class="stop-menu-button" id="exitCompletely">Salir Completamente</button>
              </div>
          `;
          
          // Estilos para el menú
          menu.style.cssText = `
              position: fixed; top: 0; left: 0; width: 100%; height: 100%;
              background: rgba(0, 0, 0, 0.8); display: flex; align-items: center;
              justify-content: center; z-index: 10000; backdrop-filter: blur(10px);
          `;
          
          const content = menu.querySelector('.stop-menu-content');
          content.style.cssText = `
              background: var(--glass-bg); border: 1px solid var(--border-subtle);
              border-radius: 20px; padding: 2rem; text-align: center;
              backdrop-filter: var(--blur-effect); box-shadow: var(--shadow-intense);
              min-width: 300px;
          `;
          
          const title = menu.querySelector('.stop-menu-title');
          title.style.cssText = `
              font-size: 1.3rem; font-weight: 700; color: var(--text-primary);
              margin-bottom: 1.5rem;
          `;
          
          const buttons = menu.querySelectorAll('.stop-menu-button');
          buttons.forEach(btn => {
              btn.style.cssText = `
                  width: 100%; padding: 0.8rem 1.5rem; margin: 0.5rem 0;
                  background: var(--primary-gradient); color: white; border: none;
                  border-radius: 12px; font-weight: 600; cursor: pointer;
                  transition: var(--transition-smooth);
              `;
              btn.addEventListener('mouseenter', () => {
                  btn.style.transform = 'scale(1.05)';
              });
              btn.addEventListener('mouseleave', () => {
                  btn.style.transform = 'scale(1)';
              });
          });
          
          document.body.appendChild(menu);
          
          // Event listeners
          menu.querySelector('#backToPlaylist').addEventListener('click', () => {
              menu.remove();
              this.backToPlaylist();
          });
          
          menu.querySelector('#exitCompletely').addEventListener('click', () => {
              menu.remove();
              this.performFullStop();
          });
          
          // Cerrar con ESC o clic fuera
          const closeMenu = (e) => {
              if (e.key === 'Escape' || e.target === menu) {
                  menu.remove();
                  document.removeEventListener('keydown', closeMenu);
              }
          };
          document.addEventListener('keydown', closeMenu);
          menu.addEventListener('click', closeMenu);
      }
      
      backToPlaylist() {
          this.resetCurrentMediaState();
          this.state.currentPlaylistIndex = -1;
          this.renderPlaylist();
          this.state.isPlaylistVisible = true;
          this.updateUIVisibility();
          this.showNotification('Vuelve a seleccionar un video de la lista.', 'success');
      }
      
      performFullStop() {
          this.resetCurrentMediaState();
          this.state.playlist = []; this.state.currentPlaylistIndex = -1;
          
          this.dom.uploadPanel.classList.remove('hidden');
          this.state.isPlaylistVisible = false;
          this.state.isSettingsVisible = false;
          this.updateUIVisibility();
          
          [this.dom.playPauseBtn, this.dom.stopBtn, this.dom.nextBtn, this.dom.prevBtn, this.dom.fullscreenBtn, this.dom.settingsToggleBtn, this.dom.playlistToggleBtn].forEach(btn => btn.disabled = true);
          this.resetStatus();
          this.renderPlaylist();

          if (!this.dom.uploadPanel.classList.contains('hidden')) {
              this.dom.folderInput.focus();
          }
      }
      
      seek(event) {
        if (!this.state.isReady) return;
        const duration = this.state.duration || (this.state.subtitles.length > 0 ? this.state.subtitles[this.state.subtitles.length - 1].end : 0);
        if (!duration) return;
        
        const rect = this.dom.progressContainer.getBoundingClientRect();
        const percent = (event.clientX - rect.left) / rect.width;
        const seekTime = duration * percent;

        if (this.state.hasVideo) {
            this.dom.videoPlayer.currentTime = seekTime / 1000;
        } else {
            this.pausedTime = seekTime;
            if (this.state.isPlaying) this.startTime = performance.now() - this.pausedTime;
        }
        this.speechSynthesis.cancel();
        this.onTimeUpdate();
      }

      // Función mejorada de actualización de tiempo con mejor sincronización
      onTimeUpdate() {
        if (!this.state.isPlaying) return;
        let currentTime, duration;

        if (this.state.hasVideo) {
            currentTime = this.dom.videoPlayer.currentTime * 1000;
            duration = this.dom.videoPlayer.duration * 1000;
        } else {
            currentTime = performance.now() - this.startTime;
            duration = this.state.subtitles.length > 0 ? this.state.subtitles[this.state.subtitles.length - 1].end : 1;
        }
        this.state.duration = duration;
        
        // Aplicar offset de sincronización
        const adjustedTime = currentTime + this.state.settings.syncOffset;

        if (duration > 0) {
          const progressPercent = Math.min(100, (currentTime / duration) * 100);
          this.dom.progressBar.style.width = `${progressPercent}%`;
          this.dom.progressBar.setAttribute('aria-valuenow', progressPercent.toFixed(2));
        }
        
        const activeSubtitle = this.state.subtitles.find(sub => adjustedTime >= sub.start && adjustedTime <= sub.end);
        
        if (this.state.settings.showSubtitles) {
            if (activeSubtitle) {
                if (activeSubtitle.index !== this.state.currentSubtitleIndex) this.handleNewSubtitle(activeSubtitle, adjustedTime);
            } else if (this.state.currentSubtitleIndex !== -1) {
                this.dom.subtitleText.classList.remove('active');
                this.state.currentSubtitleIndex = -1;
            }
        } else {
            if (activeSubtitle && activeSubtitle.index !== this.state.currentSubtitleIndex) {
                this.speechSynthesis.cancel();
                this.speak(activeSubtitle.text, [], [], adjustedTime - activeSubtitle.start);
                this.state.currentSubtitleIndex = activeSubtitle.index;
            } else if (!activeSubtitle) {
                this.state.currentSubtitleIndex = -1;
            }
        }
        
        if (currentTime >= duration && duration > 1 && !this.state.hasVideo) this.playNext(true);
        if (this.state.isPlaying) this.animationFrame = requestAnimationFrame(this.onTimeUpdate.bind(this));
      }

      // Función mejorada para manejar nuevos subtítulos con mejor sincronización
      handleNewSubtitle(subtitle, currentTime) {
        this.speechSynthesis.cancel();
        const text = subtitle.text;
        
        let words = [];
        let wordSpans = [];

        if (this.state.settings.showSubtitles && this.state.settings.karaokeHighlight) {
            const wordRegex = /[\w']+/g;
            let match;
            let html = '';
            let lastIndex = 0;
            while((match = wordRegex.exec(text)) !== null) {
                html += text.slice(lastIndex, match.index);
                html += `<span class="subtitle-word">${match[0]}</span>`;
                words.push({ text: match[0], startIndex: match.index });
                lastIndex = match.index + match[0].length;
            }
            html += text.slice(lastIndex);
            this.dom.subtitleText.innerHTML = html;
            wordSpans = this.dom.subtitleText.querySelectorAll('.subtitle-word');
        } else {
            this.dom.subtitleText.textContent = text;
        }

        this.dom.subtitleText.classList.add('active');
        this.state.currentSubtitleIndex = subtitle.index;
        this.state.subtitleStartTime = currentTime;
        
        // Calcular el retraso necesario para la síntesis de voz
        const timeIntoSubtitle = currentTime - subtitle.start;
        const voiceDelay = Math.max(0, this.state.settings.voiceLatencyCompensation - timeIntoSubtitle);
        
        // Usar un timeout más preciso para la sincronización
        setTimeout(() => this.speak(text, words, wordSpans, timeIntoSubtitle), voiceDelay);
      }

      // Función mejorada de síntesis de voz con mejor sincronización
      speak(text, words = [], wordSpans = [], timeOffset = 0) {
          if (!text || !this.state.isPlaying) return;
          
          const utterance = new SpeechSynthesisUtterance(text);
          const { settings, voices } = this.state;
          const selectedVoice = voices.find(v => v.voiceURI === settings.selectedVoiceURI);
          
          utterance.voice = selectedVoice || voices.find(v => v.lang.startsWith('es')) || voices[0];
          utterance.rate = settings.voiceRate;
          utterance.pitch = settings.voicePitch;
          
          this.state.currentUtterance = utterance;
          this.state.speechStartTime = performance.now();
          
          utterance.onstart = () => {
              this.dom.voiceIndicator.classList.add('active');
              this.state.speechStartTime = performance.now();
          };
          
          if (this.state.settings.karaokeHighlight && words.length > 0 && wordSpans.length > 0) {
              let lastWordIndex = -1;
              
              utterance.onboundary = (event) => {
                  if (event.name !== 'word') return;
                  
                  // Mejorar la precisión del resaltado de palabras
                  const speechElapsed = performance.now() - this.state.speechStartTime;
                  let wordIndex = -1;
                  
                  // Buscar la palabra más cercana basada en el índice de caracteres
                  for (let i = 0; i < words.length; i++) {
                      if (words[i].startIndex <= event.charIndex) { 
                          wordIndex = i; 
                      } else { 
                          break; 
                      }
                  }
                  
                  // Solo actualizar si es una palabra diferente
                  if (wordIndex !== -1 && wordIndex !== lastWordIndex && wordSpans[wordIndex]) {
                      wordSpans.forEach(span => span.classList.remove('highlight'));
                      wordSpans[wordIndex].classList.add('highlight');
                      lastWordIndex = wordIndex;
                  }
              };
          }

          utterance.onend = () => {
              this.dom.voiceIndicator.classList.remove('active');
              if (wordSpans.length > 0) {
                wordSpans.forEach(span => span.classList.remove('highlight'));
              }
              this.state.currentUtterance = null;
          };
          
          utterance.onerror = () => {
              this.dom.voiceIndicator.classList.remove('active');
              this.state.currentUtterance = null;
          };
          
          this.speechSynthesis.speak(utterance);
      }

      loadSettings() {
          try {
              const saved = localStorage.getItem('improvedSubtitlePlayerSettingsV7');
              const parsed = saved ? JSON.parse(saved) : this.getDefaultSettings();
              return {...this.getDefaultSettings(), ...parsed};
          } catch (e) { return this.getDefaultSettings(); }
      }
      
      saveSettings() { 
          localStorage.setItem('improvedSubtitlePlayerSettingsV7', JSON.stringify(this.state.settings)); 
      }
      
      getDefaultSettings() { 
          return { 
              voiceRate: 1.5, voicePitch: 1, fontSize: 100, syncOffset: 0, 
              voiceLatencyCompensation: 100, selectedVoiceURI: null, 
              showSubtitles: true, karaokeHighlight: false, karaokeColor: '#8A2BE2',
              muteVideo: true
          }; 
      }
      
      applySettings() {
        Object.keys(this.settingsConfig).forEach(key => {
            const config = this.settingsConfig[key];
            const value = this.state.settings[key];
            if (config.el) {
                if (config.type === 'bool') {
                    config.el.checked = value;
                    config.el.parentElement.setAttribute('aria-checked', value);
                } else { config.el.value = value; }
            }
            if (config.label) {
                const suffix = config.suffix || '';
                const displayValue = config.type === 'float' ? parseFloat(value).toFixed(1) : value;
                config.label.textContent = `${displayValue}${suffix || ''}`;
            }
        });
        this.dom.subtitleText.style.fontSize = `clamp(${this.state.settings.fontSize * 0.8}%, 3vw, ${this.state.settings.fontSize * 1.2}%)`;
        this.dom.subtitleOverlay.style.display = this.state.settings.showSubtitles ? '' : 'none';
        
        // Aplicar silenciado del video
        if (this.dom.videoPlayer) {
            this.dom.videoPlayer.muted = this.state.settings.muteVideo;
        }
        
        // Karaoke specific settings
        this.dom.karaokeToggle.disabled = !this.state.settings.showSubtitles;
        this.dom.karaokeColorContainer.classList.toggle('hidden-setting', !this.state.settings.karaokeHighlight || !this.state.settings.showSubtitles);
        document.documentElement.style.setProperty('--karaoke-color', this.state.settings.karaokeColor);
      }
      
      updateSetting(key, value) {
        this.state.settings[key] = value;
        this.applySettings();
        this.saveSettings();
      }
      
      populateVoiceList() {
        this.dom.voiceSelect.innerHTML = `<option value="">${CONSTANTS.TEXT.VOICES_LOADING}</option>`;
        if(this.state.voices.length === 0) return;
        const createOptGroup = (label, voices) => {
            const group = document.createElement('optgroup');
            group.label = label;
            voices.forEach(voice => {
                const opt = document.createElement('option');
                opt.value = voice.voiceURI; opt.textContent = `${voice.name} (${voice.lang})`;
                if (this.state.settings.selectedVoiceURI === voice.voiceURI) opt.selected = true;
                group.appendChild(opt);
            });
            return group;
        };
        this.dom.voiceSelect.innerHTML = '';
        const spanishVoices = this.state.voices.filter(v => v.lang.startsWith('es'));
        if (spanishVoices.length > 0) this.dom.voiceSelect.appendChild(createOptGroup('Voces en Español', spanishVoices));
        const otherVoices = this.state.voices.filter(v => !v.lang.startsWith('es'));
        if (otherVoices.length > 0) this.dom.voiceSelect.appendChild(createOptGroup('Otras Voces', otherVoices));

        if (!this.state.settings.selectedVoiceURI || !this.state.voices.find(v => v.voiceURI === this.state.settings.selectedVoiceURI)) {
            const defaultVoice = spanishVoices.find(v => v.default) || spanishVoices[0] || this.state.voices[0];
            if (defaultVoice) {
                this.updateSetting('selectedVoiceURI', defaultVoice.voiceURI);
                this.dom.voiceSelect.value = defaultVoice.voiceURI;
            }
        } else {
            this.dom.voiceSelect.value = this.state.settings.selectedVoiceURI;
        }
      }
      
      updateStatus(indicatorEl, textEl, type, message) {
        const icons = { [CONSTANTS.STATUS.PENDING]: '⏳', [CONSTANTS.STATUS.SUCCESS]: '✅', [CONSTANTS.STATUS.ERROR]: '❌' };
        indicatorEl.className = `status-indicator ${type}`;
        indicatorEl.textContent = icons[type];
        textEl.textContent = message;
      }
      updateVideoStatus(t, m) { this.updateStatus(this.dom.videoStatusIndicator, this.dom.videoStatusText, t, m); }
      updateSubtitleStatus(t, m) { this.updateStatus(this.dom.subtitleStatusIndicator, this.dom.subtitleStatusText, t, m); }
      updateSystemStatus(t, m) { this.updateStatus(this.dom.systemStatusIndicator, this.dom.systemStatusText, t, m); }
      
      showNotification(message, type = 'success') {
          const icons = { success: '✅', error: '❌', warning: '⚠️' };
          const titles = { success: 'Éxito', error: 'Error', warning: 'Advertencia' };
          const notif = document.createElement('div');
          notif.className = `notification ${type}`;
          notif.setAttribute('role', 'alert');
          notif.innerHTML = `<div class="notification-content"><div class="notification-icon">${icons[type]}</div><div><div class="notification-title">${titles[type]}</div><div class="notification-message">${message}</div></div></div>`;
          document.body.appendChild(notif);
          setTimeout(() => notif.classList.add('show'), 10);
          setTimeout(() => {
              notif.classList.remove('show');
              notif.addEventListener('transitionend', () => notif.remove());
          }, 4000);
      }
      
      toggleFullscreen() {
          if (!document.fullscreenElement) {
              this.dom.appContainer.requestFullscreen().catch(err => this.showNotification(`No se pudo activar pantalla completa: ${err.message}`, 'error'));
          } else {
              document.exitFullscreen();
          }
      }
      
      handleKeyPress(e) {
          if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT' || e.ctrlKey || e.metaKey) return;
          switch (e.code) {
              case 'Space': e.preventDefault(); this.togglePlayPause(); break;
              case 'KeyF': e.preventDefault(); this.toggleFullscreen(); break;
              case 'Escape': e.preventDefault(); this.stop(); break;
              case 'ArrowLeft': 
                if (e.shiftKey) { e.preventDefault(); this.playPrev(); }
                else if (this.state.isReady) { e.preventDefault(); this.seekTo(this.getCurrentTime() - 5000); }
                break;
              case 'ArrowRight':
                if (e.shiftKey) { e.preventDefault(); this.playNext(); }
                else if (this.state.isReady) { e.preventDefault(); this.seekTo(this.getCurrentTime() + 5000); }
                break;
          }
      }

      getCurrentTime() {
          if (this.state.hasVideo) return this.dom.videoPlayer.currentTime * 1000;
          if (this.state.isPlaying) return performance.now() - this.startTime;
          return this.pausedTime;
      }

      seekTo(timeInMs) {
          const duration = this.state.duration;
          if (!duration) return;
          const newTime = Math.max(0, Math.min(timeInMs, duration));
          if (this.state.hasVideo) {
              this.dom.videoPlayer.currentTime = newTime / 1000;
          } else {
              this.pausedTime = newTime;
              if (this.state.isPlaying) this.startTime = performance.now() - this.pausedTime;
          }
          this.speechSynthesis.cancel();
          this.onTimeUpdate();
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      if (!('speechSynthesis' in window) || !('Promise' in window)) {
        document.body.innerHTML = `<div style="padding:50px;text-align:center;"><h1>Navegador no compatible</h1><p>Tu navegador no soporta las tecnologías necesarias para esta aplicación (SpeechSynthesis, Promises).</p></div>`;
        return;
      }
      window.playerApp = new ImprovedSubtitlePlayer();
    });
  </script>
</body>
</html>

